---
title: "leb119-Exercises 6"
author: "Luis Borrero"
date: "7/29/2019"
output:
  html_document: default
  pdf_document: default
---

6-1. Create a data frame with counts of something. In this case, we open a package of M&M's and counted how many M&M's there is of each color. This way we can examine the distribution of colors. 
```{r}
df <- data.frame(color=c("blue","brown","green","orange","red","yellow"), count=c(12,6,8,10,6,7))
df
```

We need to create a new data frame (new) to store variables for the proportion of the pie (with the prop= argument) each slice should take depending on how many M&M's of that particular color there were in the package. We also create a label for each slice using the label= argument.To create the prop field we used the prop= argument and then format the string using the sprintf() function. The arguments inside this function specify that we want R to come up with the percentages of each color. Hence, it must divide count by the sum of the count and then multiply the resulting values by a 100. We also specify that we want one decimal.  
```{r}
library(dplyr)
new <- df %>% mutate(prop=sprintf("%0.1f",(count/sum(df$count))*100)) %>% mutate(label=paste0(toupper(color), " ", prop, "%"))
new
```

In this case, we first create a new vector for (new) based on our previous data frame (df). %>% creates a pipe that connects df to the new dataframe we want to create. We create this new data frame transforming the data in df into proportions. This is the main fucntion of mutate(), i.e. helping us transform variables. Paste0() helps us concatenate data/arguments without separation of factors. Hence, BLUE 16.9% appear together in the same line, as specified by the specifications inside paste0(). Finally, toupper() simply converts a string to its upper case; hence blue becomes BLUE. 
```{r}
library(gplots)
pie(new$count, labels=new$label, col=gplots::col2hex(new$color), main="My M&M Color Distribution")
```



6-2. First, we need to bring in the data from the Summer and Spring M&M Data Excel .csv file. The two colons (::) mean that the program needs to go to that particular library/package, in this case readr, and access a particular variable from there. 
```{r}
mnms<-readr::read_csv("http://qualityandinnovation.com/spring-summer-2017-mnms")
mnms
```

Then we can use the tally() fucntion to tally up all of our color counts. The second line thus reads: from the mnm variable, group the variable by color and tally the number of times each color appears. 
```{r}
library(dplyr)
mnms %>% group_by(color) %>% tally()
```

The next step consists in generating the appropiate labels for our pie chart. We thus use the mutate() function to convert the data into these labels. For instance, we specify that the pie slices need to be colored according to the M&M color, that their labels need to be a proportion and that those proportions need to appear as a single percentage with their appropiate sign (%). 
```{r}
library(dplyr)
new <- mnms %>% group_by(color) %>% tally() %>% mutate(color=recode(color, "BL"="blue","BR"="brown","G"="green", "O"="orange","R"="red","Y"="yellow"), prop = n/sum(n), label = paste0(color, ": ", round(prop*100,2), "%") )
```

After specifying those labels, we create the pie chart using the pie() function, where we specify that from new R should look at n, for its labels R should look at the labels from n, we give the graph title, and the respective colors of each slice. 
```{r}
pie(new$n, labels=new$label, main="My M&M Color Distribution", col=gplots::col2hex(new$color))
```

Waffle charts are related to pie charts because both of them allow you to communicate and easily visualize how parts of the data are related to the whole. To make a waffle chart in R, we first need to install the waffle package from the ggplot-based package. This allows us to use the waffle() function to create are waffle chart in one go, specifying the different parameters we want our chart to have as we did before. Since there are 100+ M&M's in the sample, we also specify that each square in the waffle chart is equal to 10 M&M's. We also define that the chart must have 10 row. 
```{r}
library(waffle)
waffle( (new$n/10), rows=10, colors=new$color, title="M&M Colors", xlab="1 square = 10 M&Ms")
```



6-3. To create a pareto chart, we need a vector of numbers that contain counts of causes for a certain outcome in different categories. In this case, the data wa generated by asking people about the they are usually late to work. We store the data of this vector in defect.counts and then match the count/number to their corresponding category, i.e. Weather, Overslept, etc. The order of counts must be the same as the order of labels.
```{r}
defect.counts <- c(12,29,18,3,34,4)
names(defect.counts) <- c("Weather","Overslept", "Alarm Failure", "Time Change","Traffic","Other")
```

We then install the qcc package and create our pareto chart using the pareto.chart() function. 
```{r}
library(qcc)
pareto.chart(defect.counts)
```

We then can add some features to our pareto chart, as labels for the y and x-axises, the title of the chart, a green horizontal line at the cumulative percentage of 80%, using the abline() function. This 80% cutoff is used in pareto charts in order to separate the "vital few" from the trivial" many given the Pareto Principle (80/20 rule). This principle states that for may events 80% of the effects come from 20% of the causes. Hence, with this line, a Pareto chart can effectively and visually identify those critical concerns so that they are addressed and prioritized.  
```{r}
pareto.chart(defect.counts, main="My Pareto Chart", xlab="Reasons", ylab="Frequency", cex.names=0.5, las=1, col=topo.colors(6))
abline(h=0.8,lwd=4,col="green")
```

